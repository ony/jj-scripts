#!/usr/bin/env bash

jj-resolve-cid() {
  [[ $# == 1 ]]
  jj --no-pager log --no-graph --template change_id --revisions "$1"
}

msg() {
  echo "$*" >&2
}

fail() {
  msg "$*"
  exit 1
}

# State after git amend (assuming top)
#
#  A‥‥A′
#  │ ╱
#  B
#
# Idea to fix:
#
# 1. Backout old A on top of A′ (-A)
#
#    -A
#   ⋰ │
#  A  A′
#  │ ╱
#  B
#
# 2. Squash -A into A′ which results in diff between A and A′ likely conflicting.
#
#  A  A*
#  │ ╱
#  B
#
# 3. Rebase that to A which resolves conflict
#
#  A*
#  │ ⋱
#  A  A*
#  │ ╱
#  B
#
# 4. Squash it into A
#
#  A′
#  │
#  B
#

sync-amend() {
  local old_hash new_hash rest
  local old_cid new_cid
  while read -r old_hash new_hash rest; do
    old_cid=$(jj-resolve-cid "$old_hash")  # A
    new_cid=$(jj-resolve-cid "$new_hash")  # A'
    [[ "$old_cid" == "$new_cid" ]] && continue  # looks like Jujutsu handled it transparently
    cat <<EOS
# $old_hash $new_hash $rest
jj backout --revisions $old_cid --destination $new_cid

# Squashing -A into A' preserving original commit message.
# Leaving new A* have only commit message and changes without A.

a_star=\$(jj-resolve-cid '$new_cid+ & description(regex:"back.* commit $old_hash")')

jj squash --use-destination-message --revision "\$a_star"

# Move A* tree on top of original A and squash it overwriting commit message
jj rebase --source $new_cid --destination $old_cid
jj describe --message '' $old_cid # truncate old message in favor of new one
EDITOR="true" \
  jj squash --revision $new_cid
EOS
  done | (set -eo pipefail; eval "$(cat)")
}

set -exo pipefail

case "$1" in
amend) "sync-$1" ;;
*) fail "Unsupported event $1" ;;
esac

